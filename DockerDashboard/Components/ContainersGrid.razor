@using DockerDashboard.Data
@using DockerDashboard.Hubs
@using DockerDashboard.Services
@using DockerDashboard.Services.DockerHost
@using Microsoft.AspNetCore.SignalR.Client
@inject IDockerHostManager DockerHostManager
@inject NavigationManager Navigation

<RadzenDataGrid @ref=grid Data="@_orderedContainers" LoadData="@LoadData" Count="@count" AllowVirtualization="true" Style="height:400px"
                AllowFiltering="true" FilterPopupRenderMode="PopupRenderMode.OnDemand" FilterCaseSensitivity="FilterCaseSensitivity.CaseInsensitive" LogicalFilterOperator="LogicalFilterOperator.Or"
                AllowSorting="true">
    <Columns>
        <RadzenDataGridColumn Title="Name">
            <Template Context="data">
                <Button class="button-link" onclick="@(() => OpenContainer(data))">@data.ContainerName.TrimStart('/')</Button>
                <RadzenStack Orientation="Orientation.Horizontal">
                    <RadzenText TextStyle="TextStyle.Caption">@data.ShortId</RadzenText>
                    @* <RadzenIcon Icon="content_copy" style="font-size=1em; width=5px; font-weight=100"></RadzenIcon> *@
                </RadzenStack>
            </Template>
        </RadzenDataGridColumn>
        <RadzenDataGridColumn Title="Image">
            <Template Context="data">
                <a href="">@data.ImageName</a>
            </Template>
        </RadzenDataGridColumn>
        <RadzenDataGridColumn Property="Status" Title="Status">
        </RadzenDataGridColumn>
        <RadzenDataGridColumn Title="Port(s)">
            <Template Context="data">
                <RadzenStack Wrap="FlexWrap.Wrap" Gap="0">
                    @foreach (var (localPort, containerPort) in data.Ports)
                    {
                        <a href="">@localPort:@containerPort</a>
                    }
                </RadzenStack>
            </Template>
        </RadzenDataGridColumn>
        <RadzenDataGridColumn Property="Created" Title="Created">
        </RadzenDataGridColumn>
        <RadzenDataGridColumn Title="Actions" Filterable="false" Sortable="false" Frozen="true">
            <Template Context="data">
                <RadzenButton Icon="play_arrow" ButtonStyle="ButtonStyle.Light"></RadzenButton>
                <RadzenButton Icon="more_vert" ButtonStyle="ButtonStyle.Light"></RadzenButton>
                <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Light"></RadzenButton>
            </Template>
        </RadzenDataGridColumn>
    </Columns>
</RadzenDataGrid>

@code {
    private RadzenDataGrid<ContainerModel> grid;
    private int count;
    private List<ContainerModel> _orderedContainers;
    private HubConnection _hubConnection;

    [Parameter]
    public long? EnvironmentId { get; set; }

    [Parameter]
    public Func<ContainerModel, Task>? OnContainerOpen { get; set; }

    private async Task OpenContainer(ContainerModel model)
    {
        if (OnContainerOpen != null)
        {
            await OnContainerOpen(model);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/containerDetailsHub"))
            .Build();

        _hubConnection.On<UpdateContainerEvent>($"{EnvironmentId}:container_update", OnContainerEvent);
        _hubConnection.On<CreateContainerEvent>($"{EnvironmentId}:container_update", OnContainerEvent);
        _hubConnection.On<DestroyContainerEvent>($"{EnvironmentId}:container_update", OnContainerEvent);
        await _hubConnection.StartAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            await grid.RefreshDataAsync();
        }
    }

    protected void OnContainerEvent(ContainerEvent @event)
    {
        //TODO: concurrency
        if (@event is UpdateContainerEvent update)
        {
            var index = _orderedContainers.FindIndex(m => m.ContainerId == update.ContainerId);
            if (index >= 0)
            {
                _orderedContainers[index].Status = update.Container.Status;
                grid.Reload();
                InvokeAsync(StateHasChanged);
            }
        }
        else if (@event is CreateContainerEvent create)
        {
            _orderedContainers.Add(create.Container);
            grid.Reload();
            InvokeAsync(StateHasChanged);
        }
        else if (@event is DestroyContainerEvent destroy)
        {
            var index = _orderedContainers.FindIndex(m => m.ContainerId == destroy.ContainerId);
            if (index >= 0)
            {
                _orderedContainers.RemoveAt(index);
                grid.Reload();
                InvokeAsync(StateHasChanged);
            }
        }
    }

    string lastfilter;
    protected async Task LoadData(LoadDataArgs args)
    {
        if (EnvironmentId == null)
        {
            return;
        }
        await Task.Yield();

        if (!string.IsNullOrEmpty(args.Filter) && lastfilter != args.Filter)
        {
            args.Skip = 0;
        }

        var query = DockerHostManager.GetContainers(EnvironmentId.Value);


        if (!string.IsNullOrEmpty(args.Filter))
        {
            lastfilter = args.Filter;
            //query = query.Where(args.Filter);
            //count = await Task.FromResult(query.Count());
        }
        else
        {
            //count = await Task.FromResult(dbContext.OrderDetails.Count());
        }

        // if (!string.IsNullOrEmpty(args.OrderBy))
        // {
        //     query = query.OrderBy(args.OrderBy);
        // }

        _orderedContainers = await query.Skip(args.Skip.Value).Take(args.Top.Value).ToListAsync();
        count = _orderedContainers.Count();
    }

    public Task RefreshDataAsync()
    {
        return grid.RefreshDataAsync();
    }

}
